module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`

{- Экземпляр Functor - 
Вызовом fmap, принимающей на вход некоторую функцию `f` и контейнер `FunMonad x`, функция последовательно применяется ко всем элементам 
с типом `a`, хранящимся в контейнере.
-}
instance Functor FunMonad where
    fmap f (FunMonad x) = FunMonad (\a -> f (x a))
	
{- Экземпляр Applicative - 
В соответствии с первым законом класса Applicative (identity law), функция `pure`, в которую передаётся значение 
произвольного типа, сохраняет его, одновременно помещая в аппликативный функтор (АП) с типом, для которого создаётся текущий экземпляр. 
Таким образом, на выходе формируется АП, содержащий оригинальное значение.

Для определения `<*>` используется бинарная операция с АП, имеющими тип `FunMonad a` (прослеживается общая аналогия с `mappend` в классе Monoid).
На выходе формируется АП, к значениям в котором последовательно применяются функции `g` (второй аргумент `<*>`) и `f` (первый аргумент), т.е. достигается
эффект композиции функций.       
-}	
instance Applicative FunMonad where
    pure x = FunMonad (\a -> x)
    (FunMonad f) <*> (FunMonad g) = FunMonad (\a -> (f a)(g a))
	
{- Экземпляр Monad -	
Определение `return` подчиняется той же идее с передачей значения в новый контекст, что и `pure`. Различие лишь в специфике контекста, результат вызова    
`return` - монадический контейнер.

Тип `>>=`:

(>>=) :: Monad m => m a -> (a -> m b) -> m b 

Из этого следует, что для получения типа `m b` (возвращаемого функцией `f`) нужно предварительно вывести значения с типом `a`. 
Используем лямбда-переменную (`\a`), текущий результат `(x a)` вызовом `f` завёртывается в `m b` и помещается в контекст `FunMonad`. 
На заключительном этапе распаковываем значения, извлекая их из контекста монады с помощью `fun`. 
На выходе получаем контейнер `FunMonad`, содержащий значения с учётом применения функции `f`. 
-}
instance Monad FunMonad where
    return x = FunMonad (\a -> x)
    FunMonad x >>= f = FunMonad (\a -> fun (f (x a)) a)   